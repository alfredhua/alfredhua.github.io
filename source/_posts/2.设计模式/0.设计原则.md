---
title: 设计原则
date: 2023-05-05
keywords: 设计原则，单一职责，开闭原则，接口隔离原则，里氏替换原则
description: 单一职责(Simple Responsibility Pinciple，SRP)是指不要存在多于一个导致类变更 的原因
top: true
tags:
  - 设计原则
categories:
  - 设计原则
---

# 单一职责

## 什么是单一职责

一个类应该有且只有一个变化的原因（指不要存在多于一个导致类变更的原因）。

## 为什么要职责划分？

如果一个类拥有多于一个的职责，则这些职责就耦合到在了一起，那么就会有多于一个原因来导致这个类的变化。对于某一职责的更改可能会损害类满足其他耦合职责的能力。这样职责的耦合会导致设计的脆弱，以至于当职责发生更改时产生无法预期的破坏。

## 案例

### 第一步
假设我们有一个Class负责两个职责:如Course既存在“直播课”职责，也存在“回播”职责，则该类如下：

```java
public class Course {
  public void study(String courseName){
    if("直播课".equals(courseName)){  
       System.out.println(courseName + "不能快进");
    }else{
       System.out.println(courseName + "可以反复回看");
    }
  }
}
```

由上面的Course可以看出，Course 类承担了两种处理逻辑。

### 第二步

但是随着迭代开发，我们的需求发生了变更，假如现在要对课程进行加密，那么直播课和录播课的加密逻辑都不一样，必须要修改代码。而修改代码逻辑势必会相互影 响容易造成不可控的风险。需要修改其中一个职责的逻辑代码，则有可能会导致另一个职责的功能发生故障。这样一来，这个Class存在两个导致类变更的原因。**如何解决这个问题呢?**

我们就要给两个职责分别用两个Class来实现，进行解耦。后期需求变更维护互不影响。
这样的设计，可以降低类的复杂度，提高类的可读性，提高系统的可维护性，降低变更引起的风险。总体来说就是一个Class/Interface/Method只负责一项职责。接下来，我们来看代码实例，还是用课程举例，我们的课程有直播课和录播课。直播课 不能快进和快退，录播可以可以任意的反复观看，功能职责不一样。我们对职责进行分离解耦，来看代码，分别创建两个类

```java
 public class LiveCourse {
    public void study(String courseName){
     System.out.println(courseName+"不能快进看"); 
    }
}   
public class ReplayCourse {
    public void study(String courseName){
      System.out.println(courseName+"可以反复回");
     }
}
```

### 第三步

但是随着业务继续发展，课程要做权限。没有付费的学员可以获取课程基本信息，已经付费的学 员可以获得视频流，即学习权限。那么对于控制课程层面上至少有两个职责。我们可以 把展示职责和管理职责分离开来，都实现同一个抽象依赖。

设计一个顶层接口,创建 ICourse 接口:

```java
public interface ICourse { 

    String getCourseName(); //获得基本信息

    byte[] getCourseVideo();//获得视频流
    
    void studyCourse();//学习课程 

    void refundCourse();//退款
}
```
此时我们可以把这个接口拆成两个接口，创建一个接口 ICourseInfo 和 ICourseManager: ICourseInfo 接口:

```java
public interface ICourseInfo {

    String getCourseName(); 

    byte[] getCourseVideo();
}

public interface ICourseManager { 

    void studyCourse();

    void refundCourse();
}

```

# 开闭原则

一个软件实体如类，模块和函数应该对扩展开放，对修改关闭。

## 什么是开闭原则

开闭原则：指一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。所谓的开闭，也正是对扩展和修改两个行为的一个原则。强调的是用抽象构建框架，用实现扩展细节。可以提高软件系统的可复用性及可维护性。开闭原则，是面向对象设计中最基础的设计原则。它指导我们如何建立稳定灵活的系统， 例如:我们版本更新，我尽可能不修改源代码，但是可以增加新功能。


## 案例

在现实生活中对于开闭原则也有体现。比如，很多互联网公司都实行弹性制作息时间， 规定每天工作8小时。意思就是说，对于每天工作8小时这个规定是关闭的，但是你什 么时候来，什么时候走是开放的。早来早走，晚来晚走。

实现开闭原则的核心思想就是面向抽象编程，接下来我们来看一段代码:

以体系为例，首先创建一个课程接口 ICourse:

```java
public interface ICourse {

    Integer getId(); 

    String getName(); 

    Double getPrice();
}
```

```java
public class JavaCourse implements ICourse{  

    private Integer Id;

    private String name;

    private Double price;
    
    public JavaCourse(Integer id, String name, Double price) { 
       this.Id = id;
       this.name = name;
       this.price = price;
    }

    public Integer getId() { 
       return this.Id;
    }
}
```

```java
public class Client{

   public static void main(Strings[] args){
     ICourse course = new JavaCourse(1,"Java",100.00);
     System.out.println("书籍名字："+course.getName()+"书籍价格："+novel.getPrice());
   }

}

```

随着项目的发展我们需要对商品的价格进行打折出售，**此时我们该如何做呢?** 

- 我们可以在Icourse中增加打折方法。
- 我们可以直接修改JavaCourse类的getPrice方法
- 我们可以增加实现类OffJavaCourse继承JavaCourse 然后在这个价格的基础上实现一个打折方法


其实我们在实际开发过程中用这三种方法都可以，因为都需要测试后上线。 在实际的开发过程中，对于这种小的需求更改，我们更偏向方法1，简单直接。如果项目熟练，开发熟练的情况下，其实我们也会自测上线。因为我们还会考虑代码的可维护性。人员的迭代更换等多种情况。
但是我们实际应该用第三种方式去实现，因为这样式付出代价 最小，风险最低的方式。

```java

public class OffJavaCourse extends JavaCourse {

    public OffJavaCourse(Integer id, String name, Double price) {
        super(id, name, price);
    }

    @Override
    public Double getPrice() {
        return super.getPrice() * 0.5 ;
    }
}

```


## 为什么使用开闭原则

- 开闭原则可以提高复用性
- 开闭原则提高了维护性。


# 接口隔离原则

接口隔离原则(Interface Segregation Principle, ISP)是指用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口。

## 定义

这个原则指导我们在设计接口时 应当注意一下几点:

1. 一个类对一类的依赖应该建立在最小的接口之上。
2. 建立单一接口，不要建立庞大臃肿的接口。
3. 尽量细化接口，接口中的方法尽量少(不是越少越好，一定要适度)。

接口隔离原则符合我们常说的高内聚低耦合的设计思想，从而使得类具有很好的 **可读性、可扩展性和可维护性** 。我们在设计接口的时候，要多花时间去思考，要考虑业务模型，包括以后有可能发生变更的地方还要做一些预判。所以，对于抽象，对业务模型的理解 是非常重要的。

## DEMO

```java
public interface IAnimal { 

    void eat();

    void fly();

    void swim();
}
```
```java
public class Bird implements IAnimal { 

    @Override
    public void eat() {} 
    
    @Override
    public void fly() {} 
    
    @Override
    public void swim() {}
    
}

```
可以看出，Bird 的 swim()方法可能只能空着，Dog 的 fly()方法显然不可能的。这时候， 我们针对不同动物行为来设计不同的接口，分别设计 IEatAnimal，IFlyAnimal 和 ISwimAnimal 接口，来看代码

```java
public interface IEatAnimal { 
   void eat();
}

public interface IFlyAnimal {
    void fly();
}

public interface ISwimAnimal {
    void swim();
}


public class Dog implements ISwimAnimal,IEatAnimal { 

    @Override
    public void eat() {}
    
    @Override
    public void swim() {}
    
}
```

# 里氏替换原则
## 定义

所有引用基类的地方必须能透明地使用其子类的对象。（子类可以替换父类）
通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任 何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不 行了，有子类出现的地方，父类未必就能适应。

## 含义

1. 子类必须完全实现父类的方法
2. 子类可以有自己的个性 
3. 覆盖或实现父类的方法时输入参数可以被放大。如果父类的输入参数类型大于子类的输入参数类型，会出现父类存在的地方，子类未必会存在，因为一旦把子类作为参数传入，调用者很可能进入子类的方法范畴。
4. 覆写或实现父类的方法时输出结果可以被缩小 父类的一个方法的返回值是一个类型 T，子类的相同方法(重载或覆写)的返
回值为 S，那么里氏替换原则就要求 S 必须小于等于 T，也就是说，要么 S 和 T 是同一个类型，要么 S 是 T 的子类。

## 优缺点
### 优点
1. 提高代码的重用性，子类拥有父类的方法和属性；
2. 提高代码的可扩展性，子类可形似于父类，但异于父类，保留自我的特性

### 缺点
1. 继承是侵入性的，只要继承就必须拥有父类的所有方法和属性，在一定程度上约束了子类，降低了代码的灵活性；
2. 增加了耦合，当父类的常量、变量或者方法被修改了，需要考虑子类的修改，所以一旦父类有了变动，很可能会造成非常糟糕的结果，要重构大量的代码。

